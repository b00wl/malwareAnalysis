#!/usr/bin/env python
from __future__ import division
import argparse
import itertools
import sys
import pprint
from tkinter import *
from tkinter import filedialog
from tkinter import messagebox

filename1 = ''
filename2 = ''

def parse_args():
    parser = argparse.ArgumentParser(description='Determine if file is malicious')
    parser.add_argument('--fileA', default='',
                        help="Pass file name within directory path")
    parser.add_argument('--fileB', default='',
                        help="Pass file name within directory path")

    args = parser.parse_args()
    return args

def parse_opcodes(filename):
    print("Parsing file: {}".format(filename))

    try:
        with open(filename) as file:
            opcodes = [opcode.rstrip('\r\n') for opcode in file]
    except:
        print("No file found by that name!")
        print("Try including the path e.g. ./analyze.py --file benign/bunzip2.asm.txt")
        exit()
    return opcodes

def analyze_opcodes(opcodes):
    print("Analyzing opcodes")
    print('Building Opcode count Matrix..') #step1
    try:
        opcode_count_matrix = opcode_count(opcodes)
        print("Successfully built the Opcode count Matrix")
    except:
        print('Unable to build opcode count Matrix',sys.exc_info())
        raise
    print('Building Probability Table') #step2
    try:
        probabilityTable = probablity_table(opcode_count_matrix)
    except:
        print('Unable to calculate probablity tables',sys.exc_info())
        raise
    print('Building Weighted Directed Graph') #step3
    try:
        weightedDirectedGraph = weighted_directed_graph(probabilityTable)
    except:
        print('Unable to build weighted directed graph',sys.exc_info())
        raise
    return weightedDirectedGraph

#step1
def opcode_count(opcodes):
    #the matrix dictionary consists of only the combinations that'll have a value. All other pairs of instructions will be 0
    matrix = {}

    #secondary iterator
    opCodeIter=iter(opcodes)
    next(opCodeIter)

    #primary iterator
    for opcode in opcodes:
        try:
            a = (opcode,next(opCodeIter))
            if a in matrix:
                matrix[a][0] += 1
            else:
                matrix.update({a:[1,0]})

        except StopIteration:
            break
    #print(sorted(matrix.items()))
    return matrix

def probablity_table(opcode_count_matrix):
    for key,group in itertools.groupby(sorted(opcode_count_matrix.keys()), lambda x:x[0]):
        # Create multiple iterators
        group,bckupGroup = itertools.tee(group)
        total_count_for_each_group = 0
        #scope for improvement. May be, we can achieve the same in 1 loop, but this not bad
        for opcodepair in bckupGroup:
            total_count_for_each_group += opcode_count_matrix[opcodepair][0]
        for opcodepair in group:
            opcode_count_matrix[opcodepair][1] = total_count_for_each_group
    pp = pprint.PrettyPrinter(indent=4)
    pp.pprint(sorted(opcode_count_matrix.items()))
    return opcode_count_matrix

def weighted_directed_graph(probablity_table):
    for opcodepair in probablity_table.keys():
        temp = probablity_table[opcodepair][0]/probablity_table[opcodepair][1]
        probablity_table[opcodepair] = temp
    pp = pprint.PrettyPrinter(indent=4)
    pp.pprint(sorted(probablity_table.items()))
    return probablity_table

def calculate_similarity_score(numberOfUniqueOpcodes,weighted_directed_graphA,weighted_directed_graphB):
    print('Similarity Score Calculation')
    similarity_score=0
    for k in weighted_directed_graphA.keys():
        weighted_directed_graphA[k] = abs(weighted_directed_graphA[k]-weighted_directed_graphB.pop(k))
    if(len(weighted_directed_graphB)>0):
        weighted_directed_graphA.update(weighted_directed_graphB)
    pp = pprint.PrettyPrinter(indent=4)
    pp.pprint(weighted_directed_graphA)
    similarity_score = pow(numberOfUniqueOpcodes,-2)*(sum(weighted_directed_graphA.values()))
    pp.pprint('Similarity Score -> {}'.format(similarity_score))

def main():
    #args = parse_args()
    #Parse file 1
    opcodesA = parse_opcodes(filename1)
    opcodesB = parse_opcodes(filename2)
    numberOfUniqueOpcodes = len({opcode for opcode in opcodesA}) # this has to be same for both A & B - have to verify with the professor
    if(len({opcode for opcode in opcodesB}) != numberOfUniqueOpcodes):
        print('The two files do not have same unique opcodes. This is not supported by the malware Analyzer')
        exit()
    calculate_similarity_score(numberOfUniqueOpcodes,analyze_opcodes(opcodesA),analyze_opcodes(opcodesB))

def import_files():
    global filename1, filename2
    root = Tk()
    root.title("OpCode Analyzer")
    root.lift()
    root.attributes('-topmost',True)
    root.after_idle(root.attributes,'-topmost',False)
    lbl = Label(root, text="Click here to import your Opcode Files")
    lbl.grid(column=0, row=0)
    filename1 = filedialog.askopenfilename(title = "Choose your opcode files",filetypes=[("Text files","*.txt")])
    print(f"filename1 : {filename1}")
    if filename1 == None or filename1 == '':
        messagebox.showerror('Error!', 'Must Select a file!')
        return
    filename2 = filedialog.askopenfilename(title = "Choose your opcode file 2",filetypes=[("Text files","*.txt")])
    if filename2 == None or filename2 == '':
        messagebox.showerror('Error!', 'Must Select a file!')
        return
    elif filename1 == filename2:
        print("Cannot compare the same file!")
        messagebox.showerror('Error!', 'Cannot compare the same file!')
        return

import_files()
main()
