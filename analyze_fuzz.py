#!/usr/bin/env python
"""This module analyzes 2 opcode files
    and tries to determine if malware is present"""

import argparse
import itertools
import sys
import pprint
import os
from tkinter import Tk, Label, filedialog, messagebox
import glob
from pathlib import Path
import itertools


FILENAME1 = ''
FILENAME2 = ''


def parse_args():
    """Parse the argument files passed in. Expects fileA, and fileB.

    Returns:
        list: The 2 argument files in args.fileA and args.fileB
    """
    parser = argparse.ArgumentParser(description='Determine if file is malicious')
    parser.add_argument('--fileA', default='',
                        help="Pass file name within directory path")
    parser.add_argument('--fileB', default='',
                        help="Pass file name within directory path")

    args = parser.parse_args()
    return args

def parse_opcodes(filename):
    """Parse the argument file into opcodes.

     Args:
        filename (str): The path of the file to parse opcodes from.

     Returns:
         list: The list of opcodes from the file
     """
    #print("Parsing file: {}".format(filename))

    try:
        if (filename.endswith('.txt') and os.path.getsize(filename) < 10000000
                and os.path.getsize(filename) > 0):
            with open(filename) as file:
                opcodes = [opcode.rstrip('\r\n') for opcode in file]
        else:
            raise IOError("Bad File!")
    except (OSError, IOError) as err:
        #print("There was an error trying to parse the file!")
        #print(0.0)
        #print(err)
        #print('Try including the path e.g. ./analyze.py --fileA asm/benign/bunzip2.asm.txt'
        #      ' --fileB asm/benign/bunzip2.asm.txt')
        exit()
    return opcodes

def analyze_opcodes(opcodes):
    """Analyze the opcodes from the files.

     Args:
        opcodes (list): The list of the opcodes.

     Returns:
         dict: The Weighted Directed Graph List
     """
    #print("Analyzing opcodes")
    #print('Building Opcode count Matrix..') #step1
    try:
        opcode_count_matrix = build_opcode_count(opcodes)
        #print("Successfully built the Opcode count Matrix")
    except:
        #print('Unable to build opcode count Matrix', sys.exc_info())
        raise
    #print('Building Probability Table') #step2
    try:
        probability_table = build_probability_table(opcode_count_matrix)
    except:
        #print('Unable to calculate probability tables', sys.exc_info())
        raise
    #print('Building Weighted Directed Graph') #step3
    try:
        weighted_directed_graph = build_weighted_directed_graph(probability_table)
    except:
        #print('Unable to build weighted directed graph', sys.exc_info())
        raise
    return weighted_directed_graph


def build_opcode_count(opcodes):
    """Build a dict of opcodes to count of appearances

     Args:
        opcodes (list): The list of the opcodes.

     Returns:
         dict: Opcodes to count of appearances
     """
    #the matrix dictionary consists of only the combinations that'll have a value.
    #All other pairs of instructions will be 0
    matrix = {}

    #secondary iterator
    opcode_iter = iter(opcodes)
    next(opcode_iter)

    #primary iterator
    for opcode in opcodes:
        try:
            tmp = (opcode, next(opcode_iter))
            if tmp in matrix:
                matrix[tmp][0] += 1
            else:
                matrix.update({tmp:[1, 0]})

        except StopIteration:
            break
    #print(sorted(matrix.items()))
    return matrix

def build_probability_table(opcode_count_matrix):
    """Build Probability Table by taking the opcode and getting the full count
        of first opcode appearances.

     Args:
        opcode_count_matrix (dict): The list of the opcodes to their count.

     Returns:
         dict: Opcodes to count of appearances
     """
    for key, group in itertools.groupby(sorted(opcode_count_matrix.keys()), lambda x: x[0]):
        # Create multiple iterators
        group, backup_group = itertools.tee(group)
        total_count_for_each_group = 0
        #scope for improvement. May be, we can achieve the same in 1 loop, but this not bad
        for opcode_pair in backup_group:
            total_count_for_each_group += opcode_count_matrix[opcode_pair][0]
        for opcode_pair in group:
            opcode_count_matrix[opcode_pair][1] = total_count_for_each_group
    #pretty = pprint.PrettyPrinter(indent=4)
    #pretty.pprint(sorted(opcode_count_matrix.items()))
    return opcode_count_matrix

def build_weighted_directed_graph(probability_table):
    """Build Weighted Directed Graph by taking the opcode divided
        by the total count of appearances.

     Args:
        probability_table (dict): The list of the opcodes to their count and total count.

     Returns:
         dict: The list of opcodes percentage of appearances.
     """
    for opcodepair in probability_table.keys():
        temp = probability_table[opcodepair][0]/probability_table[opcodepair][1]
        probability_table[opcodepair] = temp
    #pretty = pprint.PrettyPrinter(indent=4)
    #pretty.pprint(sorted(probability_table.items()))
    return probability_table

def calculate_simularity_score(
        number_of_unique_opcodes, weighted_directed_graph_a, weighted_directed_graph_b
    ):
    """Calculate the Simularity Score for both files.

     Args:
        number_of_unique_opcodes (int): The total number of unique opcodes.
        probability_table (dict): The list of the opcodes to their count and total count.
        probability_table (dict): The list of the opcodes to their count and total count.

     Returns:
         float: The Simularity Score between the files between 0-4
     """
    #print("Simularity Score Calculation")
    simularity_score = 0
    for k in weighted_directed_graph_a.keys():
        if weighted_directed_graph_b.get(k) is not None:
            weighted_directed_graph_a[k] = abs(
                weighted_directed_graph_a[k]-weighted_directed_graph_b.pop(k)
                )

    if weighted_directed_graph_b:
        weighted_directed_graph_a.update(weighted_directed_graph_b)
    #pretty = pprint.PrettyPrinter(indent=4)
    #pretty.pprint(weighted_directed_graph_a)
    simularity_score = pow(number_of_unique_opcodes, -2) * \
        (pow(sum(weighted_directed_graph_a.values()), 2))
    if simularity_score > 4:
        #print(f"Error!!!! Simularity Score too high! {simularity_score}")
        #print(0.0)
        exit()
    print(simularity_score)
    return simularity_score

def main():
    """ Main Method to Start Analyzing Opcodes.
     """
    opcodes_a = parse_opcodes(FILENAME1)
    opcodes_b = parse_opcodes(FILENAME2)
    # this has to be same for both A & B - have to verify with the professor
    number_of_unique_opcodes = len({opcode for opcode in opcodes_a})
    if len({opcode for opcode in opcodes_b}) != number_of_unique_opcodes:
        #print("""The two files do not have same unique opcodes.
        #    This is not supported by the malware Analyzer""")
        #print(0.0)
        exit()
    calculate_simularity_score(
        number_of_unique_opcodes, analyze_opcodes(opcodes_a), analyze_opcodes(opcodes_b)
        )

def import_files():
    """ Grab the files used to analyze opcodes either by UI or CLI.
     """
    global FILENAME1, FILENAME2
    args = parse_args()
    if args.fileA != '' and args.fileB != '':
        FILENAME1 = args.fileA
        FILENAME2 = args.fileB
        return
    root = Tk()
    root.title("OpCode Analyzer")
    root.lift()
    root.attributes('-topmost', True)
    root.after_idle(root.attributes, '-topmost', False)
    lbl = Label(root, text="Click here to import your Opcode Files")
    lbl.grid(column=0, row=0)
    FILENAME1 = filedialog.askopenfilename(
        title="Choose your opcode files", filetypes=[("Text files", "*.txt")])
    if FILENAME1 is None or FILENAME1 == '':
        messagebox.showerror('Error!', 'Must Select a file!')
        return
    FILENAME2 = filedialog.askopenfilename(
        title="Choose your opcode file 2", filetypes=[("Text files", "*.txt")])
    if FILENAME2 is None or FILENAME2 == '':
        messagebox.showerror('Error!', 'Must Select a file!')
        return
    if FILENAME1 == FILENAME2:
        print("Cannot compare the same file!")
        messagebox.showerror('Error!', 'Cannot compare the same file!')
        return

import_files()
main()
