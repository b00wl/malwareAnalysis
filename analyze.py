#!/usr/bin/env python
import argparse
import itertools
import sys

def parse_args():
    parser = argparse.ArgumentParser(description='Determine if file is malicious')
    parser.add_argument('--file', default='',
                        help="Pass file name within directory path")

    args = parser.parse_args()
    return args

def parse_opcodes(file):
    print("Parsing file: {}".format(file))

    try:
        with open("asm/{}".format(file)) as file:
            opcodes = [opcode.rstrip('\r\n') for opcode in file]
    except:
        print("No file found by that name!")
        print("Try including the path e.g. ./analyze.py --file benign/bunzip2.asm.txt")
        exit()
    return opcodes

def analyze_opcodes(opcodes):
    print("Analyzing opcodes")
    print('Building Opcode count Matrix..')#step 1
    try:
        opcode_count(opcodes)
        print("Successfully built the Opcode count Matrix")
    except:
        print('Unable to build opcode count Matrix',sys.exc_info())
        raise

#step1    
def opcode_count(opcodes):
    #Extract unique Opcodes to build the matrix
    uniqueOpCodes = sorted({opcode for opcode in opcodes})
    print("Extracting Unique Opcodes -> {}".format(len(uniqueOpCodes)))
    #wheneven we see ADD, get the previous element and add it to another list
    #create a dictionary with the key [opcode,opcode]. If the key is already in the dict, increment the count. Otherwise add it.    
    #idea 1 -> creating tuples for keys and preloading a dictionary with all possible tuples from the sorted unique opcode
    opCodeCountDict = {x:0 for x in itertools.product(uniqueOpCodes,repeat=2)}
    #print('All Possible Matrix combinations->',opCodeCountDict,len(opCodeCountDict))
    #Pairing up the opcodes
    #sample -> mov,or,shr,add,pop,pop,pop
    #opcodepairs -> [(mov,or),(shr,add),(pop,pop),(pop)]
    #opcodepairs1 -> [(or,shr),(add,pop),(pop,pop)]
    #Now, an union of both would yield the below,
    # [(mov,or),(shr,add),(pop,pop),(pop),(or,shr),(add,pop),(pop,pop)]
    # removing the tuples with length 1 and ordering for readability, which will tyically at the end would yield below,
    # [(mov,or),(or,shr),(shr,add),(add,pop),(pop,pop),(pop,pop)]
    # now, loop through the above and get the count of each combination, which can be directly updated in our dict (qq->do we really need the dict?)
    opcodepairs = list(itertools.islice(opcodes,0,len(opcodes),2))
    opcodepairs1 = list(itertools.islice(opcodes,1,len(opcodes),2))
    print(len(opcodepairs),len(opcodepairs1))    



def main():
    args = parse_args()
    opcodes = parse_opcodes(args.file)
    print('Opcodes Read -> {}'.format(len(opcodes)))
    analyze_opcodes(opcodes)

main()